import fs from 'fs';
import path from 'path';

const indexJsPath = path.join(process.cwd(), 'src', 'index.js');
const indexJsContent = fs.readFileSync(indexJsPath, 'utf-8');

const extractedPrompts = [];

const inquirerPromptRegex = /inquirer\.prompt\(\[([\s\S]*?)\]\)/g;
let promptArrayMatch;

while ((promptArrayMatch = inquirerPromptRegex.exec(indexJsContent)) !== null) {
  const promptArrayString = promptArrayMatch[1];

  const promptObjectRegex = /{\s*type:\s*"(.*?)",\s*name:\s*"(.*?)",\s*message:\s*"(.*?)"(?:,\s*choices:\s*\[([\s\S]*?)\])?(?:,\s*default:\s*(.*?))?[\s\S]*?}/g;
  let promptMatch;

  while ((promptMatch = promptObjectRegex.exec(promptArrayString)) !== null) {
    const prompt = {
      type: promptMatch[1],
      name: promptMatch[2],
      message: promptMatch[3],
      choices: [],
      default: undefined,
    };

    if (promptMatch[4]) {
      prompt.choices = promptMatch[4].split(',').map(c => c.trim().replace(/['"]/g, '')).filter(c => c !== '');
    }

    if (promptMatch[5]) {
      const defaultValue = promptMatch[5].trim();
      if (defaultValue === 'true') {
        prompt.default = true;
      } else if (defaultValue === 'false') {
        prompt.default = false;
      } else if (defaultValue === '' || defaultValue === '""') {
        prompt.default = '';
      } else if (defaultValue !== '' && !isNaN(defaultValue)) {
        prompt.default = Number(defaultValue);
      } else {
        prompt.default = defaultValue.replace(/['"]/g, '');
      }
    }
    extractedPrompts.push(prompt);
  }
}

const testCases = [];

for (const prompt of extractedPrompts) {
  if (prompt.name === 'projectName') continue;

  if (prompt.type === 'confirm') {
    const enableTestCase = {
      description: `should create a project with ${prompt.name} enabled`,
      options: {},
      expectedFiles: [],
      assertions: "assert.ok(fs.existsSync(projectPath), 'Project directory should exist');",
    };

    extractedPrompts.forEach(p => {
      if (p.name !== 'projectName') {
        enableTestCase.options[p.name] = p.default !== undefined ? p.default : (p.type === 'confirm' ? false : '');
      }
    });
    enableTestCase.options[prompt.name] = true;
    testCases.push(enableTestCase);

    if (prompt.default !== false) {
      const disableTestCase = {
        description: `should create a project with ${prompt.name} disabled`,
        options: {},
        expectedFiles: [],
        assertions: "assert.ok(fs.existsSync(projectPath), 'Project directory should exist');",
      };
      extractedPrompts.forEach(p => {
        if (p.name !== 'projectName') {
          disableTestCase.options[p.name] = p.default !== undefined ? p.default : (p.type === 'confirm' ? false : '');
        }
      });
      disableTestCase.options[prompt.name] = false;
      testCases.push(disableTestCase);
    }
  } else if (prompt.type === 'list') {
    prompt.choices.forEach(choice => {
      const listTestCase = {
        description: `should create a project with ${prompt.name} set to ${choice}`,
        options: {},
        expectedFiles: [],
        assertions: "assert.ok(fs.existsSync(projectPath), 'Project directory should exist');",
      };
      extractedPrompts.forEach(p => {
        if (p.name !== 'projectName') {
          listTestCase.options[p.name] = p.default !== undefined ? p.default : (p.type === 'confirm' ? false : '');
        }
      });
      listTestCase.options[prompt.name] = choice;
      testCases.push(listTestCase);
    });
  } else if (prompt.type === 'input') {
    const inputTestCase = {
      description: `should create a project with custom ${prompt.name}`,
      options: {},
      expectedFiles: [],
      assertions: "assert.ok(fs.existsSync(projectPath), 'Project directory should exist');",
    };
    extractedPrompts.forEach(p => {
      if (p.name !== 'projectName') {
        inputTestCase.options[p.name] = p.default !== undefined ? p.default : (p.type === 'confirm' ? false : '');
      }
    });
    inputTestCase.options[prompt.name] = prompt.default || (prompt.name === 'pages' ? 'testpage' : 'custom');
    testCases.push(inputTestCase);
  }
}

const generatedTestCasesPath = path.join(process.cwd(), 'src', 'test', 'generated-test-cases.js');
const fileContent = `// This file is auto-generated by test/generate-tests.js
// Do not edit this file directly. Run 'npm run test:generate' to regenerate.

import { strict as assert } from 'assert';
import fs from 'fs';
import path from 'path';

export const testCases = ${JSON.stringify(testCases, null, 2)}.map(tc => ({
  ...tc,
  assertions: (projectPath) => { eval(tc.assertions) }
}));
`;
fs.writeFileSync(generatedTestCasesPath, fileContent);

console.log(`Generated ${testCases.length} test cases in ${generatedTestCasesPath}`);